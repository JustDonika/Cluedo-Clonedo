import java.util.*;import java.awt.*;import java.awt.event.*;import java.util.List;import javax.swing.*;import javax.swing.border.*;public class GameModel{  //------------------------  // MEMBER VARIABLES  //------------------------  //Board Attributes  private static List<Card> answer = new ArrayList<>();  private static int numberPlayers;  private static boolean gameOver=false;  private boolean isMoving=false;  private static List<Player> order = new ArrayList<>();  //Board Associations  private static List<Estate> estates = new ArrayList<>();  private static List<Tile> tiles = new ArrayList<>();  private static List<Player> players = new ArrayList<>();  private static List<Card> cards = new ArrayList<>();  private static GameController controller = new GameController();  private static GameView GUI = new GameView();  //------------------------  // CONSTRUCTOR  //------------------------  public GameModel()  {    answer = new ArrayList<Card>();    order = new ArrayList<Player>();    tiles = new ArrayList<Tile>();    players = new ArrayList<Player>();    cards = new ArrayList<Card>();  }  //-----------------------  // GETTERS  //-----------------------  public List<Card> getAnswer(){    return answer;  }  public int getNumberPlayers(){    return numberPlayers;  }  public boolean getGameOver(){    return gameOver;  }  public boolean getIsMoving(){    return isMoving;  }  public List<Player> getOrder(){    return order;  }  public List<Estate> getEstates(){    return estates;  }  public List<Tile> getTiles(){    return tiles;  }  public List<Player> getPlayers(){    return players;  }  public List<Card> getCards(){    return cards;  }  public GameController getController(){    return controller;  }  public GameView getGUI(){    return GUI;  }  public void main(String[] args){    //TODO Replace with graphical equivalent    String s = GUI.narratorOptions("Welcome to Murder Madness, a game which is legally distinct from Cluedo!\nHow many players (3-4) wish to participate?", new ArrayList<String>(){{add("Four"); add("Three");}});    if(s.equals("Four")){      numberPlayers=4;    }    else{      numberPlayers=3;    }    //Now that the number of players is known, we can ask each player to decide on a character.    ArrayList<String> playerNames=new ArrayList<>(){{add("Lucilla");add("Bert");add("Malina");add("Percy");}};    for(int i=0; i<numberPlayers; i++) {      s=GUI.narratorOptions("Which character would you like to claim?", playerNames);      if(playerNames.remove(s)) {        players.add(new Player(false, 0, s));      }      else{        i--;      }    }    for(String NonPlayer : playerNames){      players.add(new Player(true, 0, NonPlayer));    }    orderSetup();    //Create and connect all tiles    tilesAndEstates();    connectTiles();    //Cards and Answer:    createCards();    //Now distribute the cards    Collections.shuffle(cards);    int startPoint = (int) (Math.random()*4);    for(int i=startPoint; i<11+startPoint; i++){      Card distributable = cards.get(0);      order.get(i%4).addCard(distributable);      cards.remove(distributable);    }    //Randomly select first player.    int firstPlay = (int) (4*Math.random());    while(order.get(firstPlay).getPlayerState()){ //Rerolls random number until valid player found.      firstPlay = (int) (4*Math.random());    }    GUI.narratorString("Game is ready! First player is "+order.get(firstPlay).getName()+ ", please pass the device to them.");    s=GUI.narratorOptions("Press continue when the correct player is ready", new ArrayList<String>(){{add("Continue");}});    //now that everything has been established, start playerTurn loop.    if(s!=new String()) {      playerTurn(firstPlay);    }  }  /**   * Sets up the order (Lucilla, Bert, Malina, Percy) for turns.   */  private static void orderSetup() {    for(int i=0; i<4; i++){      for(Player p: players){        if(i==0 && p.getName().equals("Lucilla")){          order.add(p);        }        else if(i==1 && p.getName().equals("Bert")){          order.add(p);        }        else if(i==2 && p.getName().equals("Malina")){          order.add(p);        }        else if(i==3 && p.getName().equals("Percy")){          order.add(p);        }      }    }  }  /**   * Implements cards, and assigns them artwork (courtesy of Caitlin)   */  private static void createCards() {    ArrayList<String> cardNames = new ArrayList<>(){{add("Bert");add("Lucilla");add("Malina");add("Percy");add("Broom");add("iPad");add("Knife");add("Scissors");add("Shovel");add("Manic Manor");add("Peril Palace");add("Calamity Castle");add("Haunted House");add("Villa Celia");}};    while(!cardNames.isEmpty()){      cards.add(new Card(cardNames.get(0), new ImageIcon("Features/Assets/cards/"+cardNames.get(0)+".png")));      cardNames.remove(0);    }    Card c = cards.get((int)(Math.random()*4)); cards.remove(c); answer.add(c);    c = cards.get((int)(3+Math.random()*5)); cards.remove(c); answer.add(c);    c = cards.get((int)(7+Math.random()*5)); cards.remove(c); answer.add(c);  }  /**   * Adds in tiles and estates   */  private static void tilesAndEstates() {    //Tiles    for(int x=1; x<25; x++) {      for (int y = 1; y < 25; y++) {        //Grey areas are inaccessible        if((x>11&&x<14 && (y>5&&y<8 || y>17&&y<20))/*top and bottom gray spots*/ || (y>11&&y<14 && (x>5&&x<8 || x>17&&x<20))/*Left and right gray spots*/){          Tile t = new Tile(x, y, true);          tiles.add(t);        }        //Don't cover estates for now        else if(x>2&&x<8 && y>2&&y<8 || x>2&&x<8 && y>17&&y<23 || x>17&&x<23 && y>2&&y<8 || x>17&&x<23 && y>17&&y<23 || x>9&&x<16 && y>10&&y<15){        }        else {          Tile t = new Tile(x, y, false);          tiles.add(t);        }      }    }    //now we add weapons, then estates.    ArrayList<String> WeaponNames = new ArrayList<>(){{add("Broom");add("Scissors");add("Knife");add("Shovel");add("iPad");}};    Collections.shuffle(WeaponNames);    estates.add(new Estate(3, 7, 3, 7, false, "Haunted House", null));    estates.add(new Estate(3, 7, 18, 22, false, "Calamity Castle", null));    estates.add(new Estate(18, 22, 3, 7, false, "Manic Manor", null));    estates.add(new Estate(18, 22, 18, 22, false, "Peril Palace", null));    estates.add(new Estate(10, 15, 11, 14, false, "Villa Celia", null));    for(Estate e : estates){ //Initially put one in each      e.addWeapon(new Weapon(WeaponNames.get(0), e));      WeaponNames.remove(0);      tiles.add(e);    }  }  /**   * Sets up a turn for a given player   * @param turn   */  private void playerTurn(int turn){    if (gameOver) {      return;    }    // Clear text    if(order.get(turn).getPlayerState()){//If player has made a false accusation, or non-player is involved, they are skipped for everything except accusations.      playerTurn(getNextTurn(turn));    }    Player p = order.get(turn);    GUI.displayGame(this, order.get(turn));    GUI.narratorString("Options: Roll");    Scanner userInput = new Scanner(System.in);    String command = GUI.narratorOptions("Options: Roll", new ArrayList<String>(){{add("Roll");}});    //Roll dice    int die1= (int) (1+Math.random()*6);    int die2= (int) (1+Math.random()*6);    GUI.narratorString("Roll results: "+die1+", "+die2+", total: "+(die1+die2) +"\nUse WASD or arrow keys to move.");    p.setMoves(die1+die2);    //Allow moves    String currMove="";    while(p.getMoves()>0){      if(!controller.move.equals("")){        currMove=controller.move;        controller.move="";        //Get player tile info        Tile t = p.getTile(0);        Tile[] adjacent = new Tile[4];        Tile bestFit = null;        if(t instanceof Estate){          adjacent=((Estate) t).getExitTiles();        }        else{          adjacent=t.getAdjacentTiles();        }        //EVERY MOVE OPTION:        if(currMove.equals("UP")){          for(Tile adj : adjacent){            if(bestFit==null || adj.getY()<bestFit.getY()){              bestFit=adj;            }          }          if(canEnter(bestFit, p)){            t.removePlayer(p);            p.removeTile(t);            p.addTile(bestFit);          }        }        else if(currMove.equals("DOWN")){          for(Tile adj : adjacent){            if(bestFit==null || adj.getY()>bestFit.getY()){              bestFit=adj;            }          }          if(canEnter(bestFit, p)){            t.removePlayer(p);            p.removeTile(t);            p.addTile(bestFit);          }        }        else if(currMove.equals("LEFT")){          for(Tile adj : adjacent){            if(bestFit==null || adj.getX()<bestFit.getX()){              bestFit=adj;            }          }          if(canEnter(bestFit, p)){            t.removePlayer(p);            p.removeTile(t);            p.addTile(bestFit);          }        }        else if(currMove.equals("RIGHT")){          for(Tile adj : adjacent){            if(bestFit==null || adj.getX()>bestFit.getX()){              bestFit=adj;            }          }          if(canEnter(bestFit, p)){            t.removePlayer(p);            p.removeTile(t);            p.addTile(bestFit);          }        }      }    }    turn=getNextTurn(turn);    while(order.get(turn).getPlayerState()){ //Skips movement for non-players and those eliminated.      turn=getNextTurn(turn);    }    GUI.narratorString("It seems that "+p.getName()+"'s turn has ended! Now it's "+order.get(turn).getName()+"'s turn! Pass the device to them.\nEnter any input to continue when "+order.get(turn).getName()+" is ready.");    if(userInput.next()!=new String()) {      playerTurn(turn);    }  }  //This is where a player can make a guess, and if they're confident, put their accusation to the test.  private void Accuse(Player p, int playerNo) {    Scanner userInput = new Scanner(System.in);    String accusedPlayer = "";    String suspectWeapon = "";    GUI.narratorString("Gathering intel I see! Your guess is taking place at "+((Estate) p.getTile(0)).getName() + ", what dastardly villain do you think did this? (Percy, Lucilla, Bert, Malina)");    //Get accused player    while(accusedPlayer.equals("")) {      accusedPlayer = userInput.next();      boolean isPlayer = false;      if (accusedPlayer.equals(p.getName())) {        //Clear text        GUI.narratorString("... You think it was you? Is this a confession? Oh uh, d-did I say dastardly villain earlier? I- I'm sure you had your motives, please don't hurt me.");        isPlayer=true;        //Don't need to move player in this instance.      }      else {        for (Player whodunnit : order) {          if (accusedPlayer.toLowerCase().equals(whodunnit.getName().toLowerCase())) {            //Clear text            GUI.narratorString(accusedPlayer + " eh? Always knew they were a rotten egg. Wouldn't surprise me in the slightest. Frankly, if they didn't commit this murder, they probably at least committed another one.");            isPlayer = true;            Tile t = whodunnit.getTile(0);            t.removePlayer(whodunnit);            whodunnit.removeTile(t);            whodunnit.addTile(p.getTile(0));          }        }      }      if(!isPlayer){        accusedPlayer="";        //Clear text        GUI.narratorString("As fascinating as I'm sure your input was, I was unable to get a name out of it! Please try again. (Percy, Lucilla, Bert, Malina)");      }    }    //Get suspected weapon    GUI.narratorString("Boils my blood, imagining " +accusedPlayer + " kill poor... who died again? Whoever they were, I can't get the image of them being bashed... stabbed... iPadded?\nHow did they die again? (Broom, Shovel, Scissors, iPad, Knife)");    while(suspectWeapon.equals("")) {      suspectWeapon = userInput.next();      boolean isWeapon = false;      for (Estate e : estates) {        for (Weapon w : e.getWeapons()) {          if(w.getName().toLowerCase().equals(suspectWeapon.toLowerCase())){            isWeapon=true;          }        }      }      if(!isWeapon){        suspectWeapon="";      }    }    GUI.narratorString("The " + suspectWeapon + ", a classic. Poor whatsisname never stood a chance. Are you confident enough to accuse, or do you just want to make a guess?\nYou can only accuse once in a game, so make sure you know all the information first!\nInput accuse to accuse, and anything else to guess.");    if(userInput.next().toLowerCase().equals("accuse")){      GUI.narratorString("You thought it was " + accusedPlayer + " with the " + suspectWeapon + " in the " +((Estate)p.getTile(0)).getName()+".\nThe correct answer was "+answer.get(0).getName()+" with the "+answer.get(1).getName() + " in the " + answer.get(2).getName());      if(accusedPlayer.toLowerCase().equals(answer.get(0).getName().toLowerCase()) && suspectWeapon.toLowerCase().equals(answer.get(1).getName().toLowerCase()) && ((Estate) p.getTile(0)).getName().toLowerCase().equals(answer.get(2).getName().toLowerCase())){        GUI.narratorString("Congrats! I knew you could solve the case!");        if(accusedPlayer.equals(p.getName())){          GUI.narratorString("... maybe I jumped the gun a little with congrats, you are 100% going to jail now. But hey, congrats on solving a logic puzzle to work out your own crime I guess.");        }        gameOver=true;      }      else{        p.setPlayerState(true);        //Clear text        GUI.narratorString("Damn, so close. You tried your best, but now I'm afraid you're out. I guess you can leave this to the remaining players now. Input anything to continue.");        if (!userInput.next().equals(0)) { }        boolean everyoneOut=true;        for(Player out : order){          if(!out.getPlayerState()){            everyoneOut=false;          }        }        if(everyoneOut){          GUI.narratorString("Everyone's been eliminated! The murderer has got away! Game over, you all lose.");          gameOver=true;        }      }    }    else{ //Player making a guess      GUI.narratorString("Need more info then I see. I'm sure the rest of the group can provide some info then! And if not, that is in and of itself info!");      if(!userInput.next().equals(0)) {        //Clear text      }      int index = getNextTurn(playerNo);      while(index!=playerNo){        //Clear text        Player next = order.get(index);        if(!next.getPlayerState()){          GUI.narratorString("Pass the device to " + next.getName() + "\nWhen they have the device, input anything.");        }        else{          GUI.narratorString("Pass the device to " + p.getName() + ". The player whose cards are to be checked next is eliminated (or an unclaimed character), so no player except them should know this card.\nWhen they have the device, input anything.");        }        if(!userInput.next().equals(0)){          ArrayList<Card> applicableCards = new ArrayList<>();          for(Card c : next.getHand()){            if(c.getName().toLowerCase().equals(accusedPlayer.toLowerCase()) || c.getName().toLowerCase().equals(suspectWeapon.toLowerCase()) || c.getName().equals(((Estate) p.getTile(0)).getName())){              applicableCards.add(c);            }          }          if(applicableCards.size()==1){            if(next.getPlayerState()){              GUI.narratorString("You got a refuting card from "+ next.getName() + "! That card is " + applicableCards.get(0).getName());                if(!userInput.next().equals(0)) {                  //Clear text                }              index=playerNo-1;            }            else {              GUI.narratorString("There's only one applicable card: " + applicableCards.get(0).getName() + ". You must present this to " + p.getName() + ", but first input anything, and then pass the device to them. Make sure nobody else sees it.");              if (!userInput.next().equals(0)) {                //Clear text                GUI.narratorString("You got a refuting card from " + next.getName() + "! That card is " + applicableCards.get(0).getName());                  if(!userInput.next().equals(0)) {                    //Clear text                  }                index=playerNo-1;              }            }          }          else if(applicableCards.size()>1){            if(next.getPlayerState()){              GUI.narratorString("You got a refuting card from "+ next.getName() + "! That card is " + applicableCards.get((int)(Math.random()*applicableCards.size())).getName());                if(!userInput.next().equals(0)) {                  //Clear text                }              index=playerNo-1;            }            else {              GUI.narratorString("You have multiple applicable cards! You must present one to "+p.getName()+". These cards are: ");              for(Card printable : applicableCards){                GUI.narratorString(printable.getName());              }              GUI.narratorString("Input any refuting card name to select which piece of refuting evidence to present, and then pass the device to " + p.getName());              String cardName = "";              while(cardName.equals("")){                cardName=userInput.nextLine(); //Only instance where using multiple words could be correct ie. "Haunted House". As such, nextLine() rather than next().no                boolean validName = false;                for(Card refute : applicableCards){                  if(refute.getName().toLowerCase().equals(cardName.toLowerCase())){                    validName=true;                    //Clear Text                    GUI.narratorString("You got a refuting card from "+ next.getName() + "! That card is " + cardName);                      if(!userInput.next().equals(0)) {                      }                    index=playerNo-1;                  }                }                if(!validName){                  cardName="";                }              }              if (!userInput.next().equals(0)) { }            }          }          else{            GUI.narratorString("You have no applicable cards. Input anything.");            if (!userInput.next().equals(0)) {}          }        }        if (index == 3) {          index=0;        } else {          index++;        }      }    }  }  private boolean canEnter(Tile t, Player p) {    if((t.getPlayers().isEmpty() || t instanceof Estate) && !t.getImpassible() && !p.getTravelled().contains(t)){      return true;    }    return false;  }  //This method connects all adjacent passable tiles, and estates.  private void connectTiles() {    int x=0;    int y=0;    for(Tile t : tiles){      if(!(t instanceof Estate) && !t.getImpassible()){        x=t.getX();        y=t.getY();        for(Tile comparisonT : tiles){          if(!(comparisonT instanceof Estate) && !t.getImpassible()){            if(Math.abs(comparisonT.getX()-x)+Math.abs(comparisonT.getY()-y)==1){              t.addAdjacentTile(comparisonT);              comparisonT.addAdjacentTile(t);            }          }        }      }      else if(t instanceof Estate){        Estate e = (Estate) t;        Tile connect = null;        String name = e.getName();        if(name.equals("Haunted House")){          connect=findTile(8, 4);          e.addExitTile(connect);          connect.addAdjacentTile(e);          connect=findTile(6, 8);          e.addExitTile(connect);          connect.addAdjacentTile(e);        }        if(name.equals("Calamity Castle")){          connect=findTile(4, 17);          e.addExitTile(connect);          connect.addAdjacentTile(e);          connect=findTile(8, 19);          e.addExitTile(connect);          connect.addAdjacentTile(e);        }        if(name.equals("Manic Manor")){          connect=findTile(17, 6);          e.addExitTile(connect);          connect.addAdjacentTile(e);          connect=findTile(21, 8);          e.addExitTile(connect);          connect.addAdjacentTile(e);        }        if(name.equals("Peril Palace")){          connect=findTile(17, 21);          e.addExitTile(connect);          connect.addAdjacentTile(e);          connect=findTile(19, 17);          e.addExitTile(connect);          connect.addAdjacentTile(e);        }        if(name.equals("Villa Celia")){          connect=findTile(13, 10);          e.addExitTile(connect);          connect.addAdjacentTile(e);          connect=findTile(9, 13);          e.addExitTile(connect);          connect.addAdjacentTile(e);          connect=findTile(12, 15);          e.addExitTile(connect);          connect.addAdjacentTile(e);          connect=findTile(16, 12);          e.addExitTile(connect);          connect.addAdjacentTile(e);        }      }    }    for(Player p : players){      if(p.getName().equals("Lucilla")){        findTile(12, 2).addPlayer(p);        p.addTile(findTile(12, 2));      }      if(p.getName().equals("Bert")){        findTile(2, 10).addPlayer(p);        p.addTile(findTile(2, 10));      }      if(p.getName().equals("Malina")){        findTile(10, 23).addPlayer(p);        p.addTile(findTile(10, 23));      }      if(p.getName().equals("Percy")){        findTile(23, 15).addPlayer(p);        p.addTile(findTile(23, 15));      }    }  }  public Tile findTile(int x, int y){    for(Tile t : tiles){      if(t.getX()==x && t.getY()==y){        return t;      }    }    return null;  }  public int getNextTurn(int currTurn){    if(currTurn==3){      return 0;    }    return currTurn+1;  }}